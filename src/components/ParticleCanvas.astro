---
// Particle Canvas Component
---

<canvas id="particleCanvas" class="fixed top-0 left-0 w-full h-full pointer-events-none z-0 opacity-40"></canvas>

<script>
    // Particle System
    class ParticleSystem {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.particles = [];
            this.mouse = { x: 0, y: 0 };
            this.maxParticles = 50;
            this.connectionDistance = 100;
            
            this.resize();
            this.createParticles();
            this.bindEvents();
            this.animate();
        }
        
        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }
        
        createParticles() {
            this.particles = [];
            for (let i = 0; i < this.maxParticles; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 8 + 4
                });
            }
        }
        
        bindEvents() {
            window.addEventListener('resize', () => {
                this.resize();
                this.createParticles();
            });
            
            document.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });
        }
        
        updateParticles() {
            for (let particle of this.particles) {
                // Update position
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Mouse interaction
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100) {
                    const force = (100 - distance) / 100;
                    particle.x += dx * force * 0.01;
                    particle.y += dy * force * 0.01;
                }
                
                // Bounce off edges
                if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
                if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
                
                // Keep particles within bounds
                particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
                particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
            }
        }
        
        drawParticles() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Set particle and line colors for dark theme with better contrast
            const particleColor = 'rgba(96, 165, 250, 0.9)';
            const lineColor = 'rgba(96, 165, 250, 0.3)';
            
            // Draw connections
            this.ctx.strokeStyle = lineColor;
            this.ctx.lineWidth = 1;
            
            for (let i = 0; i < this.particles.length; i++) {
                for (let j = i + 1; j < this.particles.length; j++) {
                    const dx = this.particles[i].x - this.particles[j].x;
                    const dy = this.particles[i].y - this.particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.connectionDistance) {
                        const opacity = (this.connectionDistance - distance) / this.connectionDistance;
                        this.ctx.globalAlpha = opacity * 0.3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
                        this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
                        this.ctx.stroke();
                    }
                }
            }
            
            // Draw particles
            this.ctx.globalAlpha = 0.7;
            this.ctx.fillStyle = particleColor;
            
            for (let particle of this.particles) {
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.globalAlpha = 1;
        }
        
        animate() {
            this.updateParticles();
            this.drawParticles();
            requestAnimationFrame(() => this.animate());
        }
    }

    // Initialize particle system when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        const particleCanvas = document.getElementById('particleCanvas');
        if (particleCanvas) {
            // Hide on mobile for performance
            if (window.innerWidth > 768) {
                new ParticleSystem(particleCanvas);
            } else {
                particleCanvas.style.display = 'none';
            }
        }
    });
</script>